package formula;

import java.util.Iterator;
import java.util.List;

import net.sf.javabdd.*;
import mc.BDDModel;


public class SatVisitor implements FormulaVisitor {

	private BDD sat;
	private BDDModel model;


	/**
	 * Pre: The model m should be initialized correctly.
	 * Posc: Initializes a new visitor with the parameters received.
	 */
	public SatVisitor(BDDModel m){
		sat = null;
		model = m;
	}

	@Override
	public void visit(Variable v) {
		String name = v.toString();
		int id = model.getVarID(name);
		sat = model.getFactory().ithVar(id); //restringo a aquellos estados donde la variable es true.

	}

	/** 
	 * Returns the BDD zero or one, depending if the constant value is True or false, respectively
	 * */
	@Override
	public void visit(Constant c) {
		sat = c.getValue() ? model.getFactory().one() : model.getFactory().zero();

	}

	@Override
	public void visit(Negation n) {
		n.getExpr1().accept(this);		
		sat = this.getSat().not();

	}

	@Override
	public void visit(Implication i) {
		i.getExpr1().accept(this);
		BDD sat_np = this.getSat().not();
		i.getExpr2().accept(this);
		sat = sat_np.or(this.getSat());

	}

	@Override
	public void visit(Conjunction c) {
		c.getExpr1().accept(this);
		BDD sat_p = this.getSat();
		c.getExpr2().accept(this);
		sat = sat_p.and(this.getSat());
	
	}

	@Override
	public void visit(Disjunction d) {
		d.getExpr1().accept(this);
		BDD sat_p = this.getSat();
		d.getExpr2().accept(this);
		sat = sat_p.or(this.getSat());	
	}
	
	
	public void visit(Next n){
		
	}
	
	public void visit(Until u){
		
	}

	@Override
	public void visit(OXX o) {
		// We calculate O(Xp->Xq)
        // SAT(O(Xp->Xq)) = ! E(n U n ^ EX(p ^ !q ^ E(n W false))))
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = o.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = o.getExpr2();
        expr2.accept(this);
        BDD q = this.sat.and(mod);
        BDD nq = q.not().and(mod);
        // get the normative states
        BDD ns = model.getNormative();
        // calculate the sat
        sat = EUntil(ns,ns.and(EX(p.and(nq).and(EX(EWuntil(ns, model.getFactory().zero())))))).not().and(mod);
	}

	@Override
	public void visit(OXU o) {
		// TODO Auto-generated method stub
        // We calculate O(Xp->sUt)
        // SAT(O(Xp->sUt)) = ! E(n U (n ^ (!t ^ EX(p ^ !t ^ n W !s ^ EGn))))
        
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = o.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = o.getExpr2();
        expr2.accept(this);
        BDD s = this.sat.and(mod);
        FormulaElement expr3 = o.getExpr3();
        BDD t = this.sat.and(mod);
        // we calculate the result using its CTL semantics
        // the negations are calculated taking into account the model
        BDD nots = s.not().and(mod);
        BDD nott = s.not().and(mod);
        // get the normative states
        BDD ns = model.getNormative();
        sat = EUntil(ns, ns.and(nots.or(nott.and(EX(p.and(EWuntil(nott.and(ns),nots.and(EG(ns))))))))).not().and(mod);
	}

	@Override
	public void visit(OUX o) {
		// We calculate O(pUq -> Xs)
        // the ctl semantics is O(pUq -> Xs) = !E(n U n ^ (q | (p ^ EX(!s ^ p ^ E(pUq)))))
    
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = o.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = o.getExpr2();
        expr2.accept(this);
        BDD q = this.sat.and(mod);
        FormulaElement expr3 = o.getExpr3();
        BDD s = this.sat.and(mod);
        // we calculate the result using its CTL semantics
        // the negations are calculated taking into account the model
        BDD nots = s.not().and(mod);
        // get the normative states
        BDD ns = model.getNormative();
        sat = EUntil(ns, ns.and(q.or(p.and(EX(nots.and(p.and(EUntil(p,q.and(EWuntil(ns,model.getFactory().zero())))))))))).not().and(mod);
        
	}

	@Override
	public void visit(OUU o) {
		// We calculate O(pUq -> sUt)
        // SAT(O(pUq->sUt)) = ! E(n U \phi) where:
        // \phi = E(n ^ p ^ !t U n ^ q ^ (!s \/ E(!t ^ n W n ^ !s ^ EGn)))
		int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        //TO DO: a function must be done to obtain the states of the model
        FormulaElement expr1 = o.getExpr1();
        expr1.accept(this);
        BDD p = this.sat;
        FormulaElement expr2 = o.getExpr2();
        expr2.accept(this);
        BDD q = this.sat;
        FormulaElement expr3 = o.getExpr3();
        expr3.accept(this);
        BDD s = this.sat;
        FormulaElement expr4 = o.getExpr4();
        expr4.accept(this);
        BDD t = this.sat;
        BDD nt = t.not().and(mod);
        BDD ns = t.not().and(mod);
        BDD n =   model.getNormative();
        BDD phi = EUntil(n.and(p.and(nt)), n.and(q.and(ns.or(EWuntil(nt.and(n), n.and(ns.and(EG(n))))))));
        sat = EUntil(n, phi).not().and(mod);
        
	}

	@Override
	public void visit(PXX args) {
		// we calculate P(Xp -> Xq)
        // SAT(P(Xp -> Xq)) = vX . n ^ <>((!p \/ q) ^ X)
        // NOTE: Can this be expressed as a CTL formula???
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = args.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = args.getExpr2();
        expr2.accept(this);
        BDD q = this.sat.and(mod);
        BDD n =   model.getNormative();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        BDD X = mod;
        BDD X_old = null;
        BDD notp = p.not().and(mod);
        // calculate the GFP
        while (!X.biimp(X_old).isOne()){
            X_old = X;
            X = NWeakPrevious(X.and(notp.or(q)));
        }
        // return the GFP
        sat = X;
	}

	@Override
	public void visit(PXU p) {
		/* P( Xp ~> qUr) = { GFP T / T in Normatives & T in Sat(Xp ~> qUr) &
		 *                   s in T -> ( Post_N(s) intersection T != empty ) }
		 *                   
		 * where Sat(Xp ~> qUr) = {N / Sat( P(Xp)) union Sat(P(rUt))}*/

	}

	@Override
	public void visit(PUX p) {
		/* P(  pUq ~> Xr) =? { GFP T / T in Normatives & T in Sat( pUq ~> Xr) &
		 *                   s in T -> ( Post_N(s) intersection T != empty ) }
		 *                   
		 * where Sat( pUq ~> Xr) =? {N / Sat( P(pUq)) union Sat(P(Xr))}*/

	}

	@Override
	public void visit(PUU p) {
		/* P( pUq ~> rUt) = { GFP T / T in Normatives & T in Sat(pUq ~> rUt) &
		 *                   s in  T -> ( Post_N(s) intesection T != empty ) }
		 *                   
		 * where Sat(pUq ~> rUt) = {N / Sat( P(pUq)) Union Sat(P(rUt))}*/

	}

	@Override
	public void visit(Recovery r) {
		/* R( Phi ~> Psi) = { GFP T / T in S & T in ( N Union Sat( A(Phi ~> Psi)) ) &
		 *                   s in  T -> ( Post_N(s) in T  ) }
		 *                   
		 * other 
		 * R(Phi) = { GFP T / T in S & T in ( N Union Sat( A(Phi)) ) &
		 *            s in  T -> ( Post_N(s) in T  ) }
		 */

	}

	@Override
	public void visit(AXX a) {
        //Sat(A(Xp ~> Xq) = StrongPrevious(p->q)
        
       	//calculates Sat (p->q)
		BDD sat_imp = satImplies(a.getExpr1(),a.getExpr2());
        
        int varNum = model.getFactory().varNum();
		BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
		mod = Post(mod).and(sat_imp);	//calculates all reachable states that satisfies the implication.
        
        sat = StrongPrevious(mod); // calculate the strong previous of the states that satisfies the implication
	}

	@Override
	public void visit(AXU a) {
        // we calculate A(Xp->sUt)
        // A(Xp->sUt) = ! E(Xp ^ !(sUt)) =! ((!s ^ EXp) \/ (!t ^ EX(p ^ E(!tU!s))) \/ (!t ^ EX(p ^ EG!t))  )
        // Get the states of the model in mod
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = a.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = a.getExpr2();
        expr2.accept(this);
        BDD s = this.sat.and(mod);
        FormulaElement expr3 = a.getExpr3();
        BDD t = this.sat.and(mod);
        // we calculate the result using its CTL semantics
        // the negations are calculated taking into account the model
        BDD ns = s.not().and(mod);
        BDD nt = t.not().and(mod);
        sat = (ns.and(EX(p)).or(nt.and(EUntil(nt,ns))).or(nt.and(EX(p.and(EWuntil(nt,model.getFactory().zero())))))).not().and(mod);
    }

	@Override
	public void visit(AUX a) {
        // we calculate A(sUt->Xp)
        // A(sUt->Xp) = ! E((sUt) ^ X!p) = !( t^EX(!p) \/ (p ^ EX(!p ^ E(sUt))))
        
        // Get the states of the model in mod
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = a.getExpr1();
        expr1.accept(this);
        BDD s = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = a.getExpr2();
        expr2.accept(this);
        BDD t = this.sat.and(mod);
        FormulaElement expr3 = a.getExpr3();
        BDD p = this.sat.and(mod);
        // we calculate the result using its CTL semantics
        // the negations are calculated taking into account the model
        BDD np = p.not().and(mod);
       
        sat = (t.and(EX(np)).or(p.and(EX(np.and(EUntil(s,t)))))).not().and(mod);
    }
    

	@Override
	public void visit(AUU a) {
        // we calculate A(pUq -> sUt)
        // the semantics is: A(pUq->sUt) = E(p ^ !t U (q ^!t ^ EG!t)) \/ E(p ^ !t U (q ^ E(!t U !s))) \/ E(p ^ !t U !s ^ E(pUq))
		int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        //TO DO: a function must be done to obtain the states of the model
        FormulaElement expr1 = a.getExpr1();
        expr1.accept(this);
        BDD p = this.sat;
        FormulaElement expr2 = a.getExpr2();
        expr2.accept(this);
        BDD q = this.sat;
        FormulaElement expr3 = a.getExpr3();
        expr3.accept(this);
        BDD s = this.sat;
        FormulaElement expr4 = a.getExpr4();
        expr4.accept(this);
        BDD t = this.sat;
        BDD nt = t.not().and(mod);
        BDD ns = t.not().and(mod);
        sat= (EUntil(p.and(nt),q.and(nt).and(EWuntil(nt,model.getFactory().zero()))).or(EUntil(p.and(nt), q.and(EUntil(nt,ns)))).or(EUntil(p.and(nt), ns.and(EUntil(p,q))))).not().and(mod);
        
        //BDD notq_until_not_p = AWuntil(q.not(),p.not());
        //BDD s_until_q = AUntil(s,t);
        //BDD impl = notq_until_not_p.or(s_until_q); // this BBD captures the implication !pUq -> sUt
        // we calculate the greatest fixed point
        // this is not need it as A(->) is different from O
        //BDD result = mod;
        //BDD result_old = model.getFactory().zero();
        //while (!result.biimp(result_old).isOne()){
        //    result_old = result;
        //    result = StrongPrevious(result).and(impl); // those states satisfying the implication
        //}
        //sat = impl;
        
	}

	@Override 
	public void visit(EXX e) {
		// Sat( E(Xp ~> Xq) ) = {s in S/ Post(s) intersection Sat(!p or q) != Empty}
		// calculates Sat (p->q)
		BDD sat_imp = satImplies(e.getExpr1(),e.getExpr2());
		
		int varNum = model.getFactory().varNum();
		BDD mod = model.getTransitions();		
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
    	mod = Post(mod).and(sat_imp);	//calculates all reachable states that satisfies the implication.
		
    	sat = WeakPrevious(mod); // calculate the weak previous of the states that satisfies the implication
	}

	@Override
	public void visit(EXU e) {
		// We calculate E(Xp -> sUt)
        // the CTL semantics is E(Xp->sUt) = EX(!p) \/ E(sUt)
        
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = e.getExpr1();
        expr1.accept(this);
        BDD p = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = e.getExpr2();
        expr2.accept(this);
        BDD s = this.sat.and(mod);
        FormulaElement expr3 = e.getExpr3();
        BDD t = this.sat.and(mod);
        // we calculate the result using its CTL semantics
        // the negations are calculated taking into account the model
        BDD np = p.not().and(mod);
        sat = EX(np).or(EUntil(s,t));

	}

	@Override
	public void visit(EUX e) {
		// We calculate E(sUt -> Xp)
        // the CTL semantics is E(sUt->Xp) = E(!tU!s) \/ EG(s) \/ EXp
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        // start obtaining the BDDs of the subexpressions
		FormulaElement expr1 = e.getExpr1();
        expr1.accept(this);
        BDD s = this.sat.and(mod);
        // dont know if we really ned to do the intersection with the states of the model!
        FormulaElement expr2 = e.getExpr2();
        expr2.accept(this);
        BDD t = this.sat.and(mod);
        FormulaElement expr3 = e.getExpr3();
        BDD p = this.sat.and(mod);
        BDD nt = t.not().and(mod);
        BDD ns = s.not().and(mod);
        
        sat = EUntil(nt,ns).or(EWuntil(s,model.getFactory().zero())).or(EX(p));

	}

	@Override
	public void visit(EUU e) {
		// We calculate E(pUq -> sUt)
        // the semantics is E(pUq -> sUt) = E(!qU!p) \/ EG(!q) \/ E(sUt)
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
        mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        //TO DO: a function must be done to obtain the states of the model
        FormulaElement expr1 = e.getExpr1();
        expr1.accept(this);
        BDD p = this.sat;
        FormulaElement expr2 = e.getExpr2();
        expr2.accept(this);
        BDD q = this.sat;
        FormulaElement expr3 = e.getExpr3();
        expr3.accept(this);
        BDD s = this.sat;
        FormulaElement expr4 = e.getExpr4();
        expr4.accept(this);
        BDD t = this.sat;
        BDD np = p.not().and(mod);
        BDD nq = q.not().and(mod);
        
        sat = EUntil(nq,np).or(EWuntil(nq,model.getFactory().zero())).or(EUntil(s,t));

	}

	/** 
	 * Returns the BDD that the represents the set of states of the model that satisfy the current formula.
	 * */
	public BDD getSat(){
		return sat;		
	}

    /***
     * @return returns the set of states
     * @param p: the first formula of A(pUq)
     * @param q: the second formula of A(pUq)
     */
    private BDD AUntil(BDD p, BDD q){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        q = q.and(mod); // get those states that hold q
        BDD result = q;
        BDD result_old = model.getFactory().zero();
        // this loop calculates the least fixed point
        while (!result.biimp(result_old).isOne()){
            result_old = result;
            result = StrongPrevious(result).and(p).or(q);
        }
        return result;
    }
    
    
    /***
     * @return returns the set of states
     * @param p: the first formula of A(pWq)
     * @param q: the second formula of A(pWq)
     */
    public BDD AWuntil(BDD p, BDD q){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        q = q.and(mod); // get those states that hold q
        p = p.and(mod); // get those states that hold p
        BDD result = mod;
        BDD result_old = model.getFactory().zero();
        // this loop calculates the greatest fixed point
        while (!result.biimp(result_old).isOne()){
            result_old = result;
            result.printSet();
            result = StrongPrevious(result).and(p).or(q);
        }
        return result;
    }

    
    /***
     * @return returns the set of states
     * @param p: the first formula of AGp
     */
    public BDD AG(BDD p){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        p = p.and(mod); // get those states that hold p
        return AWuntil(p,model.getFactory().zero());
    }
    

    
    /***
     * @return returns the set of states
     * @param p: the first formula of E(pWq)
     * @param q: the second formula of E(pWq)
     */
    public BDD EWuntil(BDD p, BDD q){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        q = q.and(mod); // get those states that hold q
        p = p.and(mod); // get those states that hold p
        BDD result = mod;
        BDD result_old = model.getFactory().zero();
        // this loop calculates the greatest fixed point
        while (!result.biimp(result_old).isOne()){
            result_old = result;
            result = WeakPrevious(result).and(p).or(q);
        }
        return result;
    }

    
    /***
     * @return returns the set of states
     * @param p: the first formula of EGp
     */
    public BDD EG(BDD p){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        p = p.and(mod); // get those states that hold p
        return EWuntil(p,model.getFactory().zero());
    }
    

    
    /***
     * @return returns the set of states
     * @param p: the first formula of E(pUq)
     * @param q: the second formula of E(pUq)
     */
    private BDD EUntil(BDD p, BDD q){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        q = q.and(mod); // get those states that hold q
        BDD result = q;
        BDD result_old = model.getFactory().zero();
        // this loop calculates the least fixed point
        while (!result.biimp(result_old).isOne()){
            result_old = result;
            result = WeakPrevious(result).and(p).or(q);
        }
        return result;
    }

    /***
     * @return returns the set of states that hold EXp
     * @param p: the first formula of EXp
     */
    private BDD EX(BDD p){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        p = p.and(mod); // get those states that hold p
        BDD result = WeakPrevious(p); // the result is the weak previous
        return result;
    }

    /***
     * @return returns the set of states that hold AXp
     * @param p: the first formula of AXp
     */
    private BDD AX(BDD p){
        int varNum = model.getFactory().varNum();
        BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
        p = p.and(mod); // get those states that hold p
        BDD result = StrongPrevious(p); // the result is the strong previous
        return result;
    }
    
    
	/***
	 * 
	 * @return returns the set of successors states, reached in a step from the state "s".
	 */
	private BDD Post(BDD s){
		BDD trans = model.getTransitions();
		BDD rest = trans.and(s);	
		rest = addExists(0, model.getFactory().varNum()/2, rest,model.getFactory()); 

		boolean r_primed = true;  //flag to indicates that will be changes all variables v' by v
		BDDPairing pairs = makePairsToReplace(r_primed);
		rest = rest.replaceWith(pairs);//rename each variable: v' -> v
		
		return 	rest;	
	}


	/***
	 * 
	 * @return returns the set of successors states("normal"), reached in a step from the state b.
	 */
	private BDD Post_N(BDD b){

		BDD trans = model.getTransitions();
		// calculates the set of successors states, reached in a step from the state "b"
		BDD post = Post(b);
		return post.and(model.getNormative());		
	}
	
	
	/***
	 * @param
	 * @return returns the set of previous states of the states "b".
	 */
	private BDD WeakPrevious(BDD b){
        
        int varNum = model.getFactory().varNum();
		BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
		mod = Post(mod).and(b);	//calculates those  states that are succesors of someone and hold b .
 
    	boolean r_primed = false;  //flag to indicates that will be changes all variables v by v'
		BDDPairing pairs = makePairsToReplace(r_primed);
		
       /* BDDPairing pairs = model.getFactory().makePair();             
          for (int i=0; i<varNum/2; i++)
            pairs.set(i,(varNum/2)+i);      
       */       
        
        //rename each variable: v' -> v
	    mod = mod.replaceWith(pairs);	       
	    mod = model.getTransitions().and(mod);
        return addExists(varNum/2, varNum, mod ,model.getFactory());

	}
	
	/***
	 * 
	 * @return returns the set of previous states of the states "b", in which all successors are
	 * included in the states given as parameter.-
	 */
	private BDD StrongPrevious(BDD b){
        BDD npre = WeakPrevious(b.not()); //calculates the weak previous of not b
        BDD pre = WeakPrevious(b); // calculates the weak previous of b
        return (pre.and(npre.not())); // the result is given by those sets in pre and not in npre
	}

    /***
	 *
	 * @return returns the set of normative previous states of the states "b".
	 */
	private BDD NWeakPrevious(BDD b){
        BDD norm = model.getNormative();
        int varNum = model.getFactory().varNum();
		BDD mod = model.getTransitions();
		mod = addExists(varNum/2, varNum, mod ,model.getFactory()); // obtain all states of the model.
		mod = Post(mod).and(b);	//calculates those  states that are succesors of someone and hold b .

		boolean r_primed = false;  //flag to indicates that will be changes all variables v by v'
		BDDPairing pairs = makePairsToReplace(r_primed);
		
        /*BDDPairing pairs = model.getFactory().makePair();
        for (int i=0; i<varNum/2; i++)
            pairs.set(i,(varNum/2)+i);            
        */
		
        //rename each variable: v' -> v
	    mod = mod.replaceWith(pairs);
	          
	    mod = model.getTransitions().and(mod).and(norm);
        return addExists(varNum/2, varNum, mod ,model.getFactory());
	}
	
	/***
	 *
	 * @return returns the set of normative previous states of the states "b", in which all successors are
	 * included in the states given as parameter.-
	 */
	private BDD NStrongPrevious(BDD b){
        BDD npre = NWeakPrevious(b.not()); //calculates the weak previous of not b
        BDD pre = NWeakPrevious(b); // calculates the weak previous of b
        return (pre.and(npre.not())); // the result is given by those sets in pre and not in npre
    }

    

	/***
	 * 
	 * @param f
	 * @return Compute the set Sat( P (X f) )
	 */
	private void SatPX(FormulaElement f){
		// Sat( P(X f) ) = {s in Normatives / Post_N (s) intersection Sat(f) != Empty}		
		f.accept(this);
		BDD sat_f = this.getSat();				
		sat =(Post_N(model.getNormative()).and(sat_f));
	}


	/***
	 * 
	 * @param f
	 * @return Compute the greatest fixed point of the formula 
	 */
	private void GFP(FormulaElement f){
		f.accept(this);
		sat = this.sat;

	}

	/***
	 * 
	 * @param f
	 * @return Compute the Least fixed point of the formula 
	 */
	private void LFP(FormulaElement f){
		f.accept(this);
		sat = this.sat;

	}

    /****
     * 
     * @param r_primed : Boolean flag to indicates if will be replaced all primed variables
     *  (in which case r_primed = true) or all common variables (r_primed =false).-
     * @return creates pairs to replace primed (v' -> v) or common variables (v-> v')
     */
	private BDDPairing makePairsToReplace(boolean r_primed){      

		//obtain the identifier of each variable of the BDD.
		int varNum = model.getFactory().varNum() / 2;
		BDDPairing pairs = model.getFactory().makePair();		

		if(r_primed){// creates pairs to changes variables v' by v , is to mean v -> v'
		//	System.out.println("Pairs to change v' by v ");
			for (int i=0; i<varNum; i++){
				pairs.set((varNum)+i, i);
		//		System.out.println("pair ( " + ((varNum)+i) + ", " + i + " )" );
			}   
		}else{// creates pairs to changes variables v by v',  is to mean v' -> v
		//	System.out.println("Pairs to change v by v' ");
			for (int i=0; i<varNum; i++){
				pairs.set(i,(varNum)+i);
		//		System.out.println("pair ( " + i + ", " + ((varNum)+i) + " )" );
			}   

		} 

		return pairs;
	}	
	
	
	/**
	 * Prints the set of truth assignments specified by this list.
	 * @param sol
	 */
	private void  printSolutions ( List sol){

		Iterator i = sol.iterator();
		System.out.print("\nSolutions = ");          
		while (i.hasNext()) {     	
			byte[] c1 = (byte[])i.next();

			if (c1 != null){
				System.out.print("\n[");  
				for (int j=0; j < c1.length; j++   ){
					System.out.print(c1[j]); 

					if (j != c1.length -1) //if not is the last element, prints ","
						System.out.print(",");
				} 
				System.out.print("]\n");  
			}
		} 
		System.out.print("\n\n");  
	}


	/****
	 * 
	 * @param from
	 * @param until
	 * @param b
	 * @param f
	 * @return 
	 */
	private BDD addExists(int from, int until, BDD b, BDDFactory f){
		
		BDD var;

		for(int k=from; k< until; k++){			 	
			var = f.ithVar(k);
			b = b.exist(var);
		}		
		return b;		
	}
	
	/****
	 * 
	 * @param p: first argument of the implies.
	 * @param q: second argument of the implies.
	 * @return computes "sat" of the implication, p->q
	 */
	private BDD satImplies(FormulaElement p, FormulaElement q){
		
		// rewrite the implication like a disjunction : p->q = (!p or q)
		Negation nExpr1 = new Negation("!", p);
		Disjunction or = new Disjunction("|", nExpr1, q );
		or.accept(this); //compute "sat" of this implication
		return this.sat;
	}
	



}
