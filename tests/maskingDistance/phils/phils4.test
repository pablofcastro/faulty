// This version of the faulty philosophers use only two bits to codify the state
// of a philosopher, this reduces the state space of the examples
// a enumeration type will be added in next versions of the tool
// !s0!s1 : thinking
// !s0 s1: hungry
// s0!s1: eating
// s0s1: faulty

Global fork0 : BOOL;
Global fork1 : BOOL;
Global fork2 : BOOL;
Global fork3 : BOOL;


Process OddPhil(forkL: BOOL, forkR:BOOL){
   
   s0,s1 : BOOL;
   hasL, hasR : BOOL;
   Initial: !s0 && !s1 && !hasL && !hasR && forkR && forkL;
   Normative: !(hasR && !hasL);

   //thinking -> hungry
   [hungry] !s0 && !s1 -> s1 = true;

   //thinking -> thinking
   [thinking] !s0 && !s1 -> s0 = false;

   [getLeft] !s0 && s1 && forkL && !hasL && !hasR  -> forkL=false, hasL=true;

   

   [getRight] !s0 && s1 && hasL && forkR && !hasR -> forkR = false, hasR=true;
   //[dropLeft] !s0 && s1 && hasL && !forkR && !hasR -> forkL = true, hasL=false; 

   //hungry -> eating
   [eating] !s0 && s1 && hasL && hasR -> s1 = false, s0 = true; 

   [thinking] s0 && !s1 -> s0 = false, forkL=true, forkR=true, hasR=false, hasL=false;

   //possible errors
   //[error] faulty !(s0 && s1) -> s0 = true,s1 = true;
   //[tryingGetRight] faulty !s0 && s1 && !forkR && !hasR && hasL -> s1 = true;

   //fault
   //[getRight] faulty !s0 && s1 && !hasL && forkR && !hasR -> forkR = false, hasR=true;
   //recovery
   //[dropRight] faulty !s0 && s1 && hasR && !hasL -> forkR = true, hasR=false;
}

Process EvenPhil(forkL: BOOL, forkR:BOOL){

   s0,s1 : BOOL;
   hasL, hasR : BOOL;
   Initial: !s0 && !s1 && !hasL && !hasR && forkR && forkL;
   Normative: !(hasL && !hasR); 

   //thinking -> hungry
   [hungry] !s0 && !s1 -> s1 = true;

   //thinking -> thinking
   [thinking] !s0 && !s1 -> s0 = false;

   [getRight] !s0 && s1 && forkR && !hasL && !hasR  -> forkR=false, hasR=true; 

   

   [getLeft] !s0 && s1 && hasR && forkL && !hasL -> forkL = false, hasL=true;
   //[dropRight] !s0 && s1 && hasR && !forkL && !hasL -> forkR = true, hasR=false; 

   //hungry -> eating
   [eating] !s0 && s1 && hasL && hasR -> s1 = false, s0 = true; 

   [thinking] s0 && !s1 -> s0 = false, forkL=true, forkR=true, hasR=false, hasL=false;

   //possible errors
   //[error] faulty !(s0 && s1) -> s0 = true,s1 = true;
   //[tryingGetLeft] faulty !s0 && s1 && !forkL && !hasL && hasR -> s1 = true; 

   //fault
   [getLeft] faulty !s0 && s1 && !hasR && forkL && !hasL -> forkL = false, hasL=true;
   //recovery
   //[dropLeft] faulty !s0 && s1 && hasL && !hasR -> forkL = true, hasL=false; 
   
}


Main(){
 phil1:OddPhil;
 phil2:EvenPhil;
 phil3:EvenPhil;
 phil4:EvenPhil;


 run phil1(fork3, fork0);
 run phil2(fork0, fork1);
 run phil3(fork1, fork2);
 run phil4(fork2, fork3);
}
